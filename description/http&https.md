## http
* 超文本传输协议，是实现网络协议的一种规范
* 定义了客户端和服务端之间交换报文的格式和方式
* 默认 80 端口
* TCP 作为传输层协议，保证数据可靠性
* 无状态的协议，服务端不能保存客户端的任何信息
### 请求报文
* HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟着一个实体主体。请求首部之后有一个空行，这个空行不能省略，它用来划分首部和实体
  * 请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段
  * 方法有 get, post, head, put 和 delete
  * get 和 head 类似，但是在返回的响应中，不包含请求对象。
  * put 一般是用于上传文件到服务器上 delete 删除服务器上的对象
  * 虽然请求的方法很多，但更多的是语义上的区分，get 也能做 post 操作
* example 格式
  * GET / HTTP 1.1 \
  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X  10_10_5) \
  Accept: */*
### 响应报文
* 第一行是状态行，后面是首部行，最后是实体主体
* 状态行包含三个字段：协议字段、状态码和相应的状态信息
* 实体部分是报文的主要部分，它包含了所请求的对象
* 常见状态码
  * 200 请求成功
  * 202 服务器已接收到请求，但尚未进行处理
  * 301 永久重定向
  * 302 临时重定向
  * 304 所请求资源未修改
  * 400 客户端请求的语法错误
  * 404 请求的资源不存在
  * 500 服务器内部错误
### 首部行
* 首部可以分为种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。
  * 请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机
  * 响应首部有 ETag 资源的匹配信息、Location 客户端重定向的 URL。
  * 通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接
  * Content-Length 实体主体的大小、Expire 实体主体的过期时间、Last-Modifed 资源的最后修改的时间
### HTTP 1.1 协议缺点
* 默认是用**持久连接**，多个请求可以复用同一个 TCP 连接，但是在同一个 TCP 连接里面，数据请求的通信次序是固定的
* 服务器只能处理完一个请求的响应后，才会下一个请求的处理，如果前面的请求的响应特别慢的话，造成许多请求排队的情况，这就是**队头堵塞**
* 避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们使用 雷碧图 和 合并请求脚本 的原因
### HTTP/2 协议
* **二进制协议** → HTTP/1.1 中报文的头信息必须是**文本** (ASII 编码) ，而 HTTP/2 中则是彻底的**二进制协议**，可以分为头信息帧和数据帧，帧是这是实行多路复用的基础
* **多路复用** → HTTP/2 仍复用 **TCP** 连接，但是在一个连接里，客户端和服务端可以在一个连接中同时发送多个请求或响应，而且可以不用按顺序一一发送，这一避免了 **队头堵塞** 的问题
* **数据流** → HTTP/2 使用数据流的概念, 因为 HTTP/2 的数据包是不按顺序发送的, 同一个连接里面连续的数据包, 可能属于不同的请求. 因此, 必须要对数据包做标记, 指定它属于哪个请求. HTTP/2 将每个请求或回应的数据包, 称为一个数据流. 每个数据流都有独一无二的编号. 数据包发送的时候, 都必须标记数据流 ID, 用来区分属于哪个数据流.
* **头信息压缩** → 由于 HTTP/1.1 协议不带有状态，每次请求都要附带上重复字段 cookie 和 user-agent，很浪费带宽。gzip 和 compress 压缩后发送，维护同一张头信息表，只发送索引号就好。
* **服务器推送** → HTTP/2 允许未经服务器请求，主动向客户端推送信息，这就是服务器推送。使用服务器推送，提前给客户端推送必要的资源，这样额可以相对减少一些延迟。注意这里主动推送


### HTTP 1.0 和 HTTP 1.1 的区别 - HyperText Transfer Protocol

* 1.0 默认使用非持久链接，1.0 默认使用持久链接，多个 http 请求复用一个 tcp 链接，可以有效的避免非持久连接每次建立连接的延时
* 1.0 引入了 range 头域，作用是允许只请求资源的某个部分，有利于开发者自由选择充分利用带宽
* 1.0 在缓存方面主要使用 header 里的 If-Modify-Since，Expires 来做判断缓存的标准，1.1 引入更多的缓存策略例如 Etag，If-Match，If-None-Match 供缓存头来控制缓存策略
* 1.1 引入了 host 字段 用来指定服务器的域名，在 1.0 的时候每台服务器都只绑定一个唯一的 ip 地址，因此消息中的 url 并没有传递 hostname，但随着虚拟主机的技术的发展，在一台主机可以存在多台虚拟主机，并且共享一个 ip 地址，因此 host 字段可以将请求发往同一台服务器上的不同网站
* 1.1 新增了一些方法 例如 put delete options connect trace

### 对比
* 1.0 无状态，无连接
* 1.1 持久连接，请求管道化，增加缓存字段（cache-control）,增加 host 字段，支持断点传输
* 2.0 二进制分帧，多路复用，头信息压缩，服务器推送
